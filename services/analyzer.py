import sys
import json
from datetime import datetime, timedelta
from pathlib import Path
from utils import get_worst_window 
from typing import List

class Analayzer:
    """
    This service consumes the data generated by Generator service and analyzes the logs and calculate metrics.
    """
    
    def __init__(self, file):
        self.logs = []
        self.file = Path(file)
        self.failed_requests_4xx = 0
        self.failed_requests_5xx = 0
        self.slowest_endpoint = -sys.maxsize - 1
        self.slowest_endpoint_info = ''
        self.fastest_endpoint = sys.maxsize
        self.fastest_endpoint_info = ''
        self.busiest_endpoint = ''
        self.windows = []
        self.suspicious_ips = []
        self.error_rates_by_endpoints = {}
        
        
    def analyze_and_create_report(self) -> List:
        """
        This method streams the log file line by line finds and aggregates insights from the data.
        """
        with open(self.file) as file:
            endpoint_to_num_reqs = {}
            endpoint_to_errors = {}
            MAX_REQUESTS = 15
            ip_to_reqs = {}
            window_size = timedelta(minutes=3)
            left = 0
            right = 0
            
            for line in file:
                log = json.loads(line)
                log['timestamp'] = datetime.fromisoformat(log['timestamp'])
                self.logs.append(log)
                # errors 
                http_req = log['http_request'].split()
                endpoint = http_req[1]              
                status_code = http_req[2]
                
                if status_code.startswith('4'):
                    self.failed_requests_4xx += 1
                    endpoint_to_errors[endpoint] = endpoint_to_errors.get(endpoint, 0) + 1  
                elif status_code.startswith('5'):
                    self.failed_requests_5xx += 1
                    endpoint_to_errors[endpoint] = endpoint_to_errors.get(endpoint, 0) + 1  
                    
                # number of reqs
                endpoint_to_num_reqs[endpoint] = endpoint_to_num_reqs.get(endpoint, 0) + 1      
                    
                # fastest and slowest endpoints
                response_time = log['response_time']
                
                if response_time > self.slowest_endpoint:
                    self.slowest_endpoint = response_time
                    self.slowest_endpoint_info = endpoint + " ---> " + str(response_time) + "ms"
                
                if response_time < self.fastest_endpoint:
                    self.fastest_endpoint = response_time
                    self.fastest_endpoint_info = endpoint + " ---> " + str(response_time) + "ms"
                
                # time window analysis
                start = self.logs[left]['timestamp']
                end = self.logs[right]['timestamp']
                
                if left < right:
                    if end - start > window_size:
                        window = f'{start} ---> {end}'
                        self.windows.append([window, self.failed_requests_4xx , self.failed_requests_5xx])
                        for ip in ip_to_reqs:
                            if ip_to_reqs[ip] > MAX_REQUESTS:
                                self.suspicious_ips.append(ip)
                        ip_to_reqs = {}
                        left = right
                    elif end - start < timedelta(milliseconds=100):
                        ip = log['ip']
                        ip_to_reqs[ip] = ip_to_reqs.get(ip, 0) + 1 
                            
                right += 1  
            
            start = self.logs[left]['timestamp']
            end = self.logs[right - 1]['timestamp']
            
            while left < right - 1:
                window = f'{start} ---> {end}'
                self.windows.append([window, self.failed_requests_4xx , self.failed_requests_5xx])
                for ip in ip_to_reqs:
                    if ip_to_reqs[ip] > MAX_REQUESTS:
                        self.suspicious_ips.append(ip)
                ip_to_reqs = {}
                left = right
                if end - start < timedelta(milliseconds=100):
                    ip = log['ip']
                    ip_to_reqs[ip] = ip_to_reqs.get(ip, 0) + 1 
            
            # aggregation of error rates
            for endpoint in endpoint_to_errors:   
                total_reqs_to_endpoint = endpoint_to_num_reqs[endpoint]
                errors_to_endpoint = endpoint_to_errors[endpoint]
                
                error_rate = round(errors_to_endpoint / total_reqs_to_endpoint, 3)
                
                self.error_rates_by_endpoints[endpoint] = error_rate
            
            # endpoint with the most requests
            self.busiest_endpoint = max(endpoint_to_num_reqs, key=endpoint_to_num_reqs.get) 
            self.busiest_endpoint += f" ---> {endpoint_to_num_reqs[self.busiest_endpoint]} requests"
            
            # report data
            return {
                "total_requests": len(self.logs),
                "total_failed_requests": self.failed_requests_4xx + self.failed_requests_5xx,
                "failed_requests_4xx": self.failed_requests_4xx,
                "failed_requests_5xx": self.failed_requests_5xx,
                "slowest_endpoint": self.slowest_endpoint,
                "slowest_endpoint_info": self.slowest_endpoint_info,
                "fastest_endpoint": self.fastest_endpoint,
                "fastest_endpoint_info": self.fastest_endpoint_info,
                "busiest_endpoint": self.busiest_endpoint,
                "worst_window": get_worst_window(self.windows),
                "suspicious_ips": self.suspicious_ips,
                "error_rates_by_endpoints": self.error_rates_by_endpoints,
            }